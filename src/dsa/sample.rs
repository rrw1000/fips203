// Sampling

use crate::{
    dsa::{convert, matrix},
    format,
    types::Bytes,
    types::IntRange2Or4,
};
use anyhow::Result;
use sha3::{
    Shake128, Shake256,
    digest::{ExtendableOutput, Update, XofReader},
};

pub fn sample_in_ball(p: &[u8], tau: u32) -> Result<[i32; 256]> {
    // H is SHAKE256.
    let mut c: [i32; 256] = [0; 256];
    let mut xof = Shake256::default();
    xof.update(p);
    let mut reader = xof.finalize_xof();
    let mut s: [u8; 8] = [0; 8];
    reader.read(&mut s);
    let h_val = format::bytes_to_bits(&s[..])?;
    let h = h_val.as_slice();
    for i in 256 - (tau as usize)..256 {
        let mut j: [u8; 1] = [0];
        reader.read(&mut j);
        while (j[0] as usize) > i {
            reader.read(&mut j);
        }
        c[i] = c[j[0] as usize];
        // -1^1 == -1 , -1 ^^ 2 = 1.
        c[j[0] as usize] = if h[i + (tau as usize) - 256] % 2 == 1 {
            -1
        } else {
            1
        };
    }
    Ok(c)
}

pub fn rej_ntt_poly(p: &[u8]) -> Result<[i32; 256]> {
    let mut a_hat: [i32; 256] = [0; 256];
    let mut j = 0;
    // G is SHAKE128
    let mut ctx = Shake128::default();
    ctx.update(p);
    let mut reader = ctx.finalize_xof();
    while j < 256 {
        let mut s: [u8; 3] = [0; 3];
        reader.read(&mut s);
        // It's difficult to say what's intended here when CoeffF
        if let Some(v) = convert::coeff_from_three_bytes(s[0], s[1], s[2]) {
            a_hat[j] = v as i32;
            j += 1;
        }
    }
    Ok(a_hat)
}

pub fn rej_bounded_poly(p: &[u8], n: IntRange2Or4) -> Result<[i32; 256]> {
    let mut a: [i32; 256] = [0; 256];
    let mut j = 0;
    // H is SHAKE256
    let mut ctx = Shake256::default();
    ctx.update(p);
    let mut reader = ctx.finalize_xof();
    while j < 256 {
        let mut s: [u8; 1] = [0; 1];
        reader.read(&mut s);
        let z0 = convert::coeff_from_half_byte(s[0] & 0xf, n);
        let z1 = convert::coeff_from_half_byte((s[0] >> 4) & 0xf, n);
        if let Some(v) = z0 {
            a[j] = v;
            j += 1;
        }
        if j < 256 {
            if let Some(v) = z1 {
                a[j] = v;
                j += 1;
            }
        }
    }
    Ok(a)
}

pub fn expand_a(p: &[u8], k: u32, l: u32) -> Result<matrix::Matrix> {
    let mut result = matrix::Matrix::new(k as usize, l as usize);
    for r in 0..k {
        for s in 0..l {
            let mut p_prime = Bytes::from(p);
            // All integer_to_bytes() does here is push a single byte
            p_prime.as_vec_mut().push(s as u8);
            p_prime.as_vec_mut().push(r as u8);
            println!("r = {r} s = {s}");
            *result.value(r as usize, s as usize) = rej_ntt_poly(p_prime.as_bytes())?;
        }
    }
    Ok(result)
}

pub fn expand_s(
    p: &[u8],
    k: u32,
    l: u32,
    n: IntRange2Or4,
) -> Result<(matrix::Vector, matrix::Vector)> {
    let mut s1 = matrix::Vector::default();
    for r in 0..l {
        let mut local_p = Bytes::from(p);
        local_p.accumulate(convert::integer_to_bytes(r, 2));
        let v = rej_bounded_poly(local_p.as_bytes(), n)?;
        s1.as_vec_mut().push(v);
    }
    let mut s2 = matrix::Vector::default();
    for r in 0..k {
        let mut local_p = Bytes::from(p);
        local_p.accumulate(convert::integer_to_bytes(r + l, 2));
        let v = rej_bounded_poly(local_p.as_bytes(), n)?;
        s2.as_vec_mut().push(v);
    }
    Ok((s1, s2))
}

pub fn expand_mask(p: &[u8], mu: u32, gamma_1: u32, l: u32) -> Result<matrix::Vector> {
    let mut result = matrix::Vector::default();
    let c = 1 + convert::bitlen(gamma_1 - 1);
    for r in 0..l {
        let mut p_prime = Bytes::from_bytes(p);
        p_prime.accumulate(convert::integer_to_bytes(mu + r, 2));
        // H is SHAKE256
        let mut xof = Shake256::default();
        xof.update(p_prime.as_bytes());
        let mut v = Bytes::zero((32 * c) as usize);
        xof.finalize_xof_into(v.as_bytes_mut());
        result
            .as_vec_mut()
            .push(convert::bit_unpack(v.as_bytes(), gamma_1 - 1, gamma_1)?);
    }
    Ok(result)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::Bytes;

    #[test]
    fn test_expand_mask() {
        let p = Bytes::from_hex("db37c386ec2734e1e210301840f627353f055ca9a46dd8b7fea6cd5ec36cc8a0")
            .unwrap();
        let mask = expand_mask(p.as_bytes(), 4, 1 << 17, 4).unwrap();
        let expect_first: [i32; 256] = [
            -109380, -51628, 27896, 31189, -71635, -96211, 25524, -9451, -22958, -113050, -62649,
            45781, -95076, 33909, -11149, 3313, -54927, 20632, 113004, -26834, 118060, -20120,
            -5666, 22193, -47525, -37667, -53260, 23378, -114718, -100320, 86532, 88067, -37228,
            -53499, 27510, -21584, -14789, -86103, -35688, 30314, 85909, 8365, -108123, 98200,
            45461, 48562, 52884, -116566, -51226, 81575, -87177, 59868, -58878, 63478, -84221,
            105540, 21821, 17233, -67824, -123601, 57138, -49832, 34152, -36499, 88858, -123871,
            5028, 103404, 110623, 22193, 99405, -104357, 98256, -107644, -90911, 62058, -38674,
            58591, -49444, -64342, -98715, -28921, 85886, -83263, 101828, -2761, -6691, 79282,
            -90783, 80224, 62059, 111320, -102027, -4455, -110420, -40228, 118583, -62661, -36394,
            75134, 127856, -10379, -7520, -71234, -21024, 50239, -717, 32168, -15044, 53118,
            124369, 67769, -51533, 82823, -128027, 21078, 46461, 18514, 77444, 36835, -45439,
            35620, 101111, 27330, -11304, 98544, 92635, 108664, -46934, 19828, -123877, -129154,
            1775, 7396, 87043, -97070, -72390, -115876, -107800, 32905, -41209, 56604, -81829,
            123467, 74986, -10994, -37003, -33302, 86427, -108139, -36109, 5071, 31114, 126213,
            18786, 86588, -55763, -15606, -66332, -130053, -75353, 119826, -121756, 114001, 71018,
            112058, -51474, 103649, 4203, -73614, 93277, 57905, -106782, -42824, 22631, 107803,
            107028, -127440, -48905, -90322, -70621, 16987, -21969, -118640, -17846, -90345, 27245,
            73830, 50855, 119037, -115135, -29798, 33128, 130386, 128702, 7788, 100462, -16445,
            40320, -29820, 25477, -54431, -2317, -123744, -115930, 76767, -35642, 112577, 28705,
            130256, -36079, -23224, 109107, -52956, -2254, 35465, -54793, 22762, 88685, 23668,
            59737, 16511, -49828, 127690, 28679, -102001, -45999, -65340, -116674, -98542, 31891,
            24592, 107909, -7581, 11965, 92979, -31306, -16721, -97373, 35042, 96384, 2827, 105598,
            84309, 116341, -79338, -96614, -2842, 22240, -102210, 67970, 11231, 104487, 80646,
            79866, -60753,
        ];

        assert_eq!(expect_first, *mask.at(0));
    }

    #[test]
    fn test_expand_s() {
        let p = Bytes::from_hex("db37c386ec2734e1e210301840f627353f055ca9a46dd8b7fea6cd5ec36cc8a0")
            .unwrap();
        let (a, _) = expand_s(p.as_bytes(), 4, 2, IntRange2Or4::Two).unwrap();
        let expect_00 = [
            -2, -1, -1, 0, -2, 0, -2, -2, 1, 1, 2, -1, -1, -2, -1, 2, 1, 0, -2, 0, 0, -1, 0, 0, 2,
            -2, -1, 2, 2, 2, -1, -1, -1, 1, 0, 0, 0, -2, -1, 1, -2, 2, 0, -1, 2, 2, -1, 0, 2, 2, 2,
            0, 2, 0, 1, -1, 2, -2, -2, -2, 2, -2, 0, 0, -2, 1, -2, 2, -1, 1, -2, 2, -2, -2, 2, 0,
            0, 2, 1, 2, 2, -2, 2, 2, 2, -2, 0, -2, 0, -2, 1, 1, -1, -1, 1, 0, 0, 1, -2, 0, -2, 1,
            2, -1, 0, -2, 0, 1, 2, 2, 0, 2, -1, 1, 1, 1, 0, 1, -2, 1, 1, -1, 1, -1, -1, 1, 2, 0, 0,
            -1, 1, 2, 2, 2, 2, 1, 2, 1, 0, -2, 1, 2, 2, -1, 1, 0, 0, -1, 1, 0, 0, 1, -2, 1, -2, 2,
            2, 2, -1, 2, 1, 2, 0, -2, 2, -2, 1, 2, 2, -2, -1, -2, 2, 2, 2, 2, -2, 2, 2, -2, 2, 0,
            -1, 0, 0, 1, -2, 2, 2, -1, 2, 2, 1, 1, -2, 2, -2, 0, 1, 1, 2, -2, 0, -1, -1, 1, -1, 1,
            2, -2, 1, 0, 2, 2, -1, -1, -1, 0, 2, -1, 1, -2, -2, 1, 0, -1, 1, -2, -2, 2, 2, 1, -1,
            1, 1, -1, 0, 1, -2, 0, -2, -2, 2, -2, 1, 2, -2, -1, 2, 2, -2, 0, 0, 1, 2, 2,
        ];
        assert_eq!(&expect_00, a.at(0));
    }

    #[test]
    fn test_expand_a() {
        // Yet another regression test!
        let p = Bytes::from_hex("db37c386ec2734e1e210301840f627353f055ca9a46dd8b7fea6cd5ec36cc8a0")
            .unwrap();
        let a = expand_a(p.as_bytes(), 2, 4).unwrap();
        assert_eq!(
            a.at(0, 0),
            &[
                1932321, 8112544, 3016324, 3600319, 1373697, 7931820, 7492495, 7794843, 5976993,
                2411734, 4667780, 5773203, 2973132, 742356, 3194884, 1690776, 5600752, 8174025,
                8062912, 1106435, 2009132, 4424608, 2403724, 439956, 1912068, 7741193, 7272226,
                6342264, 1939349, 7939827, 6828553, 844724, 7953107, 3067481, 2254256, 3767976,
                4005943, 2648585, 1489651, 8168794, 6850427, 3499641, 2658771, 942438, 4542048,
                3345875, 2541977, 2957106, 7840268, 3180277, 8092384, 1216225, 3653232, 5409757,
                3461015, 960378, 2862933, 5518302, 5285446, 6769294, 7616710, 2658896, 6498486,
                6888483, 1657921, 1322466, 2040019, 2735370, 1729514, 1094573, 2282099, 5950886,
                2020622, 356287, 5228849, 3063719, 1625530, 2825164, 920397, 580163, 5977605,
                3646696, 2955830, 588616, 6104993, 1209648, 4753234, 2953986, 5910008, 5393758,
                5200912, 1667333, 4927774, 1790427, 7135466, 5272687, 8351524, 3894179, 870814,
                5754234, 2715624, 7858719, 5964263, 6627525, 1465324, 7359117, 1320488, 7945342,
                3628093, 1155606, 521091, 6465038, 2980910, 522769, 5537612, 756708, 6371284,
                3779774, 3321493, 8110733, 2643057, 2506086, 1740529, 4794701, 4948642, 1808635,
                3113366, 6242199, 458240, 6844303, 5752011, 4631835, 421596, 1204236, 626000,
                7672608, 3774132, 1038619, 253425, 3189294, 23645, 6671402, 3150606, 5105585,
                3628024, 6101525, 4114394, 6180245, 2072984, 6620428, 639630, 5653739, 5773007,
                2921785, 7035813, 6703451, 7819656, 2364707, 4410815, 2586924, 4083986, 359140,
                4934169, 5276535, 1635496, 3815390, 6717929, 2250048, 7049343, 1546316, 148267,
                2790979, 915863, 8098008, 6485696, 2203339, 6188501, 5536996, 8143093, 4590879,
                6156048, 2406796, 7565551, 2497805, 1357463, 1661883, 7510223, 5707585, 6764340,
                1416980, 6312845, 6932793, 749324, 1371513, 5590051, 4756558, 4252562, 8058694,
                4477469, 3295075, 2696448, 7227933, 1412272, 7180171, 6855750, 2709673, 1394729,
                2313765, 5181486, 1908382, 4319657, 1648620, 5693280, 2201418, 6133423, 1096267,
                1906202, 3738268, 3485427, 5311831, 8106054, 1393907, 7466471, 4422047, 1064956,
                2920966, 8316866, 7892373, 8231795, 3137978, 7332778, 7733738, 593941, 1530031,
                7703438, 4340549, 4254952, 8146555, 8066709, 5655025, 7446077, 1415660, 4176694,
                788651, 6390513, 5658040, 2073298, 1164215, 4908409, 7192470, 334353, 5767486,
                858722, 2184989, 1042976, 2378415
            ]
        );
    }

    #[test]
    fn test_rej_bounded_poly() {
        // Should be 66 of these.
        // This is a pure regression test let p =
        let p = Bytes::from_hex("124be522e3740ce4f0feb782523e2ee5f2f69959fe75b3a03107143d322a0cb865f77bb92d72a4f41c3098b8c36a91f3a6919a651af597b9b2737bf5b7e62010208f").unwrap();
        let poly = rej_bounded_poly(p.as_bytes(), IntRange2Or4::Two).unwrap();
        let expected = [
            1, -1, -1, 0, -2, -2, -2, 0, 1, 0, -1, -1, 1, -1, 0, 0, 2, 2, -1, 2, 0, 2, 0, -2, 2, 2,
            2, 1, 0, 0, -2, -2, 0, 2, 1, 2, -2, 2, 2, 1, 0, 2, -2, 1, -1, 2, 0, -2, -2, 2, -1, -1,
            -1, -1, -1, -1, -1, 0, 2, 1, -2, 0, -2, 0, -1, -2, 0, -2, -1, 1, -2, 2, 0, 1, 1, -1,
            -1, -1, -2, 1, 2, -1, 1, 2, 2, -1, -2, 0, 0, 0, 1, -2, 1, -1, 0, 1, -1, 0, -1, 1, -2,
            -1, -2, 0, 0, -1, 2, -2, -1, -2, -2, 2, 0, 2, 2, 1, 0, 0, 1, 0, 2, -2, -1, -2, 2, -2,
            2, 1, -2, 1, 2, -1, 2, -1, 2, 0, -1, -2, 2, -2, -1, 1, -1, 0, 0, 1, 0, -1, 1, 1, 2, 0,
            -2, 2, 1, 2, -1, -1, 2, 1, 1, 0, 0, -1, 1, 1, 1, -1, 0, 1, -1, -1, 2, -2, 1, -1, 1, -2,
            0, -1, 2, 2, -2, 2, 2, -1, 0, -2, -1, 2, -2, 0, -1, -2, -2, 1, 1, 0, -1, -2, 2, 2, 0,
            -1, 2, -2, 0, 2, 0, -1, 0, -1, 1, 2, 1, 2, -1, 1, -1, -2, -2, 0, 0, 1, 0, 1, -2, -1,
            -1, -2, 0, -2, 0, -2, -1, -2, -1, 1, 1, -2, 1, -1, -2, 0, 0, 2, 2, -1, 0, -2, -2, -1,
            2, 0, 0, 1,
        ];
        assert_eq!(expected, poly);
    }

    #[test]
    fn test_rej_ntt_poly() {
        // Pure regression again
        let p =
            Bytes::from_hex("1e5448396ccfb504b459a6e4ba703de49ba44747ad3bed4228580d5becec32703e30")
                .unwrap();
        let sampled = rej_ntt_poly(p.as_bytes()).unwrap();
        let expected = [
            3418534, 1505795, 896770, 5643102, 1087491, 1470728, 338287, 4316045, 6778135, 3335538,
            321423, 275989, 6678742, 7855871, 1460980, 4676041, 1538892, 5182846, 6938972, 4696639,
            5852410, 2254199, 3931888, 8086891, 5046391, 942665, 3294635, 6074197, 2489007,
            1126151, 3148526, 109632, 6153489, 1951125, 6000052, 2686940, 5625741, 6201392,
            5951485, 7752406, 4768418, 1887157, 226542, 2077204, 3720710, 347630, 4637789, 1978252,
            7107740, 498357, 378565, 4592650, 5310283, 2542570, 5657038, 6620887, 4946280, 902643,
            7406579, 514552, 3800084, 6007464, 1195422, 7316878, 270372, 1827503, 252728, 398388,
            5309618, 2900599, 650941, 8019493, 3742853, 5306985, 4799982, 5704446, 7096850,
            8261619, 1315669, 643612, 5618262, 7593897, 2356785, 3306163, 424876, 1460382, 2299731,
            111038, 7464597, 1647196, 6237655, 2067285, 7904553, 4037536, 6162087, 1857815,
            7375631, 7815464, 1727806, 7895232, 2560150, 4132124, 6051031, 3695725, 8096962,
            3546256, 3054225, 3125014, 1200941, 7195149, 983944, 3305720, 2763702, 6024129,
            8237454, 8338241, 3330584, 3002985, 3567877, 5768348, 6507682, 7518727, 7483401,
            3656096, 3322763, 7313763, 148316, 724419, 1226567, 3321049, 2487496, 3862905, 4880816,
            2178800, 5574299, 1722589, 6618478, 3318328, 4559819, 4941409, 515993, 5425344,
            4675132, 3340210, 5147201, 6851283, 2333736, 1138019, 2363659, 2680345, 3069386,
            3191788, 4461414, 2006879, 1093546, 3373098, 3258055, 294084, 6708713, 4120381,
            7575168, 4276480, 2186154, 1413450, 5090352, 5938759, 4735990, 2353712, 772417,
            6006983, 3517307, 7264619, 1798879, 8326293, 1748773, 5525405, 4738689, 4863752,
            1243508, 2490534, 1471746, 6058904, 7369739, 3284484, 272426, 3284777, 7519154, 755282,
            4478808, 6718926, 4840133, 1173575, 8191068, 2439877, 973599, 5671743, 8253458,
            6544848, 1055583, 6029709, 7328584, 2342393, 3139282, 4351448, 7459784, 4154610,
            8092221, 1872737, 5770733, 1269698, 5703989, 570875, 6263834, 4453260, 3064621,
            5877033, 709359, 3917138, 2095793, 660472, 6975967, 3208769, 6736714, 6034411, 1223873,
            2087371, 3096289, 2309482, 8158795, 4710826, 2555951, 5564951, 7584329, 759957,
            6349619, 2735783, 10000, 3363417, 8091349, 3160074, 4670495, 4274329, 2129477, 1728738,
            108374, 8271244, 8267817, 5258070, 7087459, 2757701, 7585677, 5122529, 7499971,
            2285513, 6548792, 8256295,
        ];
        assert_eq!(expected, sampled);
    }

    #[test]
    fn test_sample_in_ball() {
        // Pure regression ..
        let p = Bytes::from_hex("1234567890").unwrap();
        let in_ball = sample_in_ball(p.as_bytes(), 20).unwrap();
        let expected = [
            0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, -1, 0, 1, 0, 0, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, -1, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0,
        ];
        assert_eq!(expected, in_ball);
    }
}
