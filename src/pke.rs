use crate::{
    basics, matrix, sample,
    types::{Bytes, Bytes32, IntRange2To3},
};
use anyhow::Result;

/// This could be a tuple; it is only here to ensure that before you use a (private) decryption key
/// you have to type "private_dec", which will hopefully make you think about where you are exposing it.
#[derive(Default, Clone)]
pub struct KeyPair {
    pub public_enc: Bytes,
    pub private_dec: Bytes,
}

/// A parameter set; intentionally no Default() - you need to select your encryption strength explicitly.
#[derive(Eq, PartialEq, Clone)]
pub struct ParamSet {
    // n = 256, q = 3329 always.
    pub k: u32,
    pub n1: IntRange2To3,
    pub n2: IntRange2To3,
    pub du: u32,
    pub dv: u32,
    pub required_rbg_bits: u32,
}

impl ParamSet {
    pub fn ml_kem_512() -> ParamSet {
        ParamSet {
            k: 2,
            n1: IntRange2To3::Three,
            n2: IntRange2To3::Two,
            du: 10,
            dv: 4,
            required_rbg_bits: 128,
        }
    }

    pub fn ml_kem_768() -> ParamSet {
        ParamSet {
            k: 3,
            n1: IntRange2To3::Two,
            n2: IntRange2To3::Two,
            du: 10,
            dv: 4,
            required_rbg_bits: 192,
        }
    }

    pub fn ml_kem_1024() -> ParamSet {
        ParamSet {
            k: 4,
            n1: IntRange2To3::Two,
            n2: IntRange2To3::Two,
            du: 11,
            dv: 5,
            required_rbg_bits: 256,
        }
    }

    /// Purely internal keygen function. Returns (ek,dk)
    fn k_pke_keygen(&self, d: &Bytes32) -> Result<(Bytes, Bytes)> {
        let mut random_bytes = Bytes::new();
        random_bytes.as_vec_mut().extend_from_slice(d.as_bytes());
        // We know it fits because max k == 4
        random_bytes.as_vec_mut().push(self.k as u8);
        let (p, sigma) = basics::g(&random_bytes)?;
        let mut big_n = 0;
        let mut a_matrix = matrix::SquareMatrix::new(self.k);
        for i in 0..self.k {
            for j in 0..self.k {
                let mut b = Bytes::new();
                b.as_vec_mut().extend_from_slice(p.as_bytes());
                b.as_vec_mut().push(j as u8);
                b.as_vec_mut().push(i as u8);
                a_matrix.set(i, j, &sample::sample_ntt(&b)?);
            }
        }
        let mut s = matrix::Vector::new(self.k);
        for i in 0..self.k {
            s.set(
                i,
                &sample::sample_poly_cbd(&basics::prf(self.n1, &sigma, big_n), self.n1)?,
            );
            big_n += 1;
        }
        let mut e = matrix::Vector::new(self.k);
        for i in 0..self.k {
            e.set(
                i,
                &sample::sample_poly_cbd(&basics::prf(self.n1, &sigma, big_n), self.n1)?,
            );
            big_n += 1;
        }
        let s_hat = s.ntt()?;
        let e_hat = e.ntt()?;
        let t_hat = a_matrix.compose_hat(&s_hat)?.add(&e_hat)?;
        let mut ek_pke = Bytes::new();
        let mut dk_pke = Bytes::new();
        for i in 0..self.k {
            let e_value = basics::byte_encode(&t_hat.at(i), 12)?;
            ek_pke.accumulate(e_value);
            ek_pke.as_vec_mut().extend(p.as_bytes());
            let d_value = basics::byte_encode(&s_hat.at(i), 12)?;
            dk_pke.accumulate(d_value);
        }
        Ok((ek_pke, dk_pke))
    }

    /// Alg 16 ; returns (ek,dk)
    fn keygen_internal(&self, d: &Bytes32, z: &Bytes32) -> Result<(Bytes, Bytes)> {
        let (ek_pke, dk_pke) = self.k_pke_keygen(&d)?;
        let mut dk = Bytes::new();
        dk.accumulate(dk_pke);
        dk.accumulate(ek_pke.clone());
        dk.accumulate_32(basics::h(&ek_pke)?);
        dk.accumulate_32(*z);
        Ok((ek_pke, dk))
    }

    // Somewhat pointless, but the standard does it, so we should too :-)
    pub fn keygen(&self, d: &Bytes32, z: &Bytes32) -> Result<KeyPair> {
        let (ek, dk) = self.keygen_internal(d, z)?;
        Ok(KeyPair {
            public_enc: ek,
            private_dec: dk,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_k_pke_keygen_512() {
        struct TestSet {
            d: Bytes32,
            v: Bytes32,
            ek: Bytes,
            dk: Bytes,
        }
        // At last, we can use the test vectors :-)
        let test_vectors = vec![TestSet {
            v: Bytes32::from_hex(
                "1A394111163803FE2E8519C335A6867556338EADAFA22B5FC557430560CCD693"
            ).unwrap(),
            d: Bytes32::from_hex(
                "1EB4400A01629D517974E2CD85B9DEF59082DE508E6F9C2B0E341E12965955CA",
            )
            .unwrap(),
            ek: Bytes::from_hex(
                "5B318622F73E6FC6CBA5571D0537894AA890426B835640489AA218972180BB2534BCC477C62CC839135934F3B14CD0808A11557D331103B30F9A8C0CB0FA8F0A2A152E802E48E408087510D5114D4D2399A51530616C7E310528308176D0042710BC8344EC3D4CA810A92978BFABB516D81CAB0753CDF325AC2377A1F96EFC73C15F5AA367A1582A13651B0337C7943C1D54637669686BEBBD392511FFFC9E3A68CBEEC0CE2CF59A8D51C4DE288EB4641DF6610C82D09CDDA418ACD83F0DCA2859B27117E87981AAA8EBA47515812DA2C27ADF9C682E373D5AF294BE3104474B8D14173788965ECCD80322B6CA04240E7D150F2CD4B04066C1924039B9E4A9E06C2B55DBA2FDDABB4065CFE7EBC5AE01CD45C76374683CB1820C34A841836391B9D8C2AA22B29E7436CFCAB789B3CE8AE2700351C1165B7B4F72CC53E913E5668AE75170352A0DE68A5E3819443DB4113161A2019C4930C97011F31540B833E9A890503A7EC3F38C0D94BE3C7501C6161F39099E3CAC0139ACC7271B70D1664A36A89FA4D22857C6C15AD4C52D5C26E23B81DCDA9FD7A49980C5818888AB2538AD91F54E691B7558C63FAE433A7FAB51485989F4335E6187B65041401238AA0A5A932356207796AF2C70363034546F4615499245E1228BFF2C76674634A60C9A04E00FB276C6C00A114BF1B2C8961E740A082940CEEAAB464370BBBB3919C7421BC81C732415A711AA935A4C2C02CB5D0BCBB99CE830EDDBAE4C228E4F095E29FBC27EA2B881697A1D309D28C480C3E9691FB63480BC5C6239B6CCAA41CD52A6209038C2C887BC71C1BD514A0FAA21721A2A5B30ACB168227833A8260422C1F4815EC2ADB207389FB1B817D78FC96063434B6728E18469475DB5D712BC403D8231CF9C8926D0A94B6830881FA5678AD04499F40D5CA83479BA85A70B1196C32A68A6B7FFB40EA6FC3FF020768B91B27F653746546C5E256B14069E827C1616FC7647F8B70F8A32DB551CF715BBB315B7B9BC20FF76847CFC4AEAC23DDC1302EC928CFE40447C761143194DA1415D3D8389F61BAB41EB605729123A320BB54B3B3FBCBC787C46F354C7D7D60F8DFE3729375AEF1891C08A79DE237E39E860061D",
            ).unwrap(),
            dk: Bytes::from_hex(
                "EA35075D429C8E81ADA6C4BB97D78624C602FB173DFFC78E5C744FF2FAC345B55E04A3B7325A63F58B43EEF168E259910C35A0952A7ADCF43634889C98918A1CE7B62671C1968A02688160C09B7DE9978B77A557D265A40F7C79F3124247FA0C14F8A9F2C2B939470CAD5ACA5E664ADD7B5444643B559C4BF84C524A063DA7E552C9107BB0887BC22C73F76B63ABA60955A06D1CF34491275859D46FEDEA738FEC14D9920458A7C31E657549A6160480784D5C229AD88932B384A0B0A16DD6C8FCEA56B61A50E67442FB9928B4676D92A6717A564D8E939BB7957D750BB70D2B20D8445A8912BC7940489AE01584DC7D7952A686F245D09C547EF40B74C6748B318059F66F2B76C72ECBB3A64167CAE08C27368902B76DFF684A14482AFAE5837CB6838E685987FA4E3FF7CC4A36631CBA1F77915E7C580853E3C6C84859ADC8C2A15CB131E78305F4BCB4A8100AAB206EC97D14862CF5DA4D3AE2066D4C41BBA9187BECBE0809CE6AAC1FE20BCAE87714BE1542BA9053F1802B65C82909594984A186841B2BFCB3AF38100C5E685E7B9B85515C469CA50B1F799229E024B68A4A412A185677444491689957A576F5029C742DB64C3F63614B43AA23C433A1B37811CDC1184E11BB7D9C20E587A862B364EF59651259B26F8375E4510CBB12A475816A364BA72C07566D50A2B4E4503188B7B465080DB88EE663928C894367492E1617CCBF36CF844B9D17072A3178809629B4B9729CF82C9935AA9B1205AEA6631C8EE23CEE832C46E0583FAC43C5BC5131B934527740AB12877D295C72089073E6A2567B655CCB2965FAA3DECA8315815E7B6514F05BACE8A7000B548993734DE3964F2709542496122BE58A7E536CC827839693492AE88E75EA13154AB109E6BD16F4486EE1C3EA61B8FA259283B3BC2BFB589D3206A3C77521AA08C253B4E4CC8B5F87467EEA18EBD48D92604382DB0C0087A3B501066CB55EC9602D2696380A6A5DF33C05C9B01700B61D0FC169DEBC28B3108B096B24D93B8FFE67066286B0E1461265896E33A8089D8B0B81A9781700A983B28022125A4934575220325B318622F73E6FC6CBA5571D0537894AA890426B835640489AA218972180BB2534BCC477C62CC839135934F3B14CD0808A11557D331103B30F9A8C0CB0FA8F0A2A152E802E48E408087510D5114D4D2399A51530616C7E310528308176D0042710BC8344EC3D4CA810A92978BFABB516D81CAB0753CDF325AC2377A1F96EFC73C15F5AA367A1582A13651B0337C7943C1D54637669686BEBBD392511FFFC9E3A68CBEEC0CE2CF59A8D51C4DE288EB4641DF6610C82D09CDDA418ACD83F0DCA2859B27117E87981AAA8EBA47515812DA2C27ADF9C682E373D5AF294BE3104474B8D14173788965ECCD80322B6CA04240E7D150F2CD4B04066C1924039B9E4A9E06C2B55DBA2FDDABB4065CFE7EBC5AE01CD45C76374683CB1820C34A841836391B9D8C2AA22B29E7436CFCAB789B3CE8AE2700351C1165B7B4F72CC53E913E5668AE75170352A0DE68A5E3819443DB4113161A2019C4930C97011F31540B833E9A890503A7EC3F38C0D94BE3C7501C6161F39099E3CAC0139ACC7271B70D1664A36A89FA4D22857C6C15AD4C52D5C26E23B81DCDA9FD7A49980C5818888AB2538AD91F54E691B7558C63FAE433A7FAB51485989F4335E6187B65041401238AA0A5A932356207796AF2C70363034546F4615499245E1228BFF2C76674634A60C9A04E00FB276C6C00A114BF1B2C8961E740A082940CEEAAB464370BBBB3919C7421BC81C732415A711AA935A4C2C02CB5D0BCBB99CE830EDDBAE4C228E4F095E29FBC27EA2B881697A1D309D28C480C3E9691FB63480BC5C6239B6CCAA41CD52A6209038C2C887BC71C1BD514A0FAA21721A2A5B30ACB168227833A8260422C1F4815EC2ADB207389FB1B817D78FC96063434B6728E18469475DB5D712BC403D8231CF9C8926D0A94B6830881FA5678AD04499F40D5CA83479BA85A70B1196C32A68A6B7FFB40EA6FC3FF020768B91B27F653746546C5E256B14069E827C1616FC7647F8B70F8A32DB551CF715BBB315B7B9BC20FF76847CFC4AEAC23DDC1302EC928CFE40447C761143194DA1415D3D8389F61BAB41EB605729123A320BB54B3B3FBCBC787C46F354C7D7D60F8DFE3729375AEF1891C08A79DE237E39E860061D2B87926182B602639ABB65FEBAF116F6A2FCCC167A51A2E2E6F4494C58336A2E1A394111163803FE2E8519C335A6867556338EADAFA22B5FC557430560CCD693",
            ).unwrap()
        }];
        let ml_kem_512 = ParamSet::ml_kem_512();
        for t in test_vectors {
            let kp = ml_kem_512.keygen(&t.d, &t.v).unwrap();
            assert_eq!(t.ek, kp.public_enc);
            assert_eq!(t.dk, kp.private_dec);
        }
    }
}
